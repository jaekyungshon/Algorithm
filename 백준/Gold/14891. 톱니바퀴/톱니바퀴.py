"""
난이도 : 쉬움~보통
시간 : 30분

[첫번째 제출 틀림 이유]
인덱스를 제대로 설정하자..

[요구사항 파악]
핵심 : "조건을 어떻게 구현할 것인가"

두 그룹으로 나눌 수 있다. (1번/4번), (2번/3번)

[먼저, 첫번째 그룹을 보자.(1번 톱니바퀴를 생각해보자)]
1번 톱니바퀴를 회전시키면 다음과 같은 순서로 회전하는지 파악해야한다.
    1번과 2번 -> 성공 -> 2번과 3번 -> 성공 -> 3번과 4번
             -> 실패
                                -> 실패 -> 성공? 실패?
=> 2번이 회전 실패하면, 3번과 4번은 볼 필요없음.
=> 성공시, 순차적으로 다음 톱니바퀴의 회전을 생각해보면 됨.
=> 이때, 톱니바퀴에 해당되는 인덱스는 다음과 같다. (input을 이차원 배열로 받기!)
    - 1번과 2번 : idx=(2,6) -- arr[1][2], arr[2][6]
    - 2번과 3번 : idx=(2,6) -- arr[2][2](2시), arr[3][6](6시)
    - 3번과 4번 : idx=(2,6) -- arr[3][2], arr[4][6]
=> 즉, 직관적인 2차원 배열관점에서 다음과 같이 보게 된다. (숫자에 괄호로 표시)
    10(1)01111
    011111(0)1
    11(0)01110
    000000(1)0
=> 여기서 알 수 있는 점은 다음과 같다.
    1. 1번~2번, 2번~3번, 3~4번 : 3가지의 조건 발견
    2. 2번과 3번 톱니바퀴 각각 2시, 6시 극을 동시에 가진다.
        예) 1번~2번 : 2번 톱니바퀴 해당 극은 6시
            2번~3번 : 2번 톱니바퀴 해당 극은 2시
그러므로, 입력에서 1번 톱니바퀴 회전을 주게 되면 3가지 조건만 프로세스를 검토하면 된다.
    1. 1번~2번 -> 성공? 실패?
    1-1. 실패 시, 2~4번 바퀴는 회전 X
    2. 성공 시, 2번~3번 -> 성공? 실패?
    2-1. 실패 시, 3번과 4번 바퀴 회전 X
    3. ...
4번 톱니바퀴의 경우는 '1번 바퀴 프로세스의 역이다.' => 1번과 4번을 그룹지어 생각하게 된 이유.

[그렇다면, 이번에는 2번째 그룹을 살펴보자.(2번/3번)]
2번 톱니바퀴를 회전시키면 다음과 같은 순서로 회전되는지 파악해야한다.
    (1) : 2번과 1번 -> 성공? 실패?
    (2) : 2번과 3번 -> 성공 -> 3번과 4번
=> 즉, 여기에서는 위의 순서 설명의 괄호 안 숫자처럼 2가지로 나뉘게 된다. (1),(2)
=> 프로세스는 첫번째 그룹과 비슷하나 큰 경우가 2가지로 나뉘는 것 뿐.

[회전 방향]
=> 이는 쉽게 생각할 수 있다.
=> 예) input : 3 -1 : 3번 톱니바퀴 / 반시계방향
    이는 1번과 3번 톱니바퀴는 반시계, 2번과 4번은 시계방향이다.
=> 즉 input의 첫번째 원소가 홀수이면 반시계를, 짝수이면 시계를 주면 된다.

[최종 정리]
이 두 그룹을 아우르는 방식은 '타겟 톱니바퀴를 기준으로, 왼쪽/오른쪽 톱니바퀴들을 순차적으로 검토하는 것.'
그러므로, 다음과 같이 알고리즘을 설계할 수 있다.

[알고리즘 설계]
1. input값 모두 받기 (톱니바퀴 리스트)
2. 반복문을 통해 회전 명령 input값 받기
(한번의 반목문에서 비교 프로세스 진행)
3. conditons 변수 리스트에 1번~2번 회전 조건, 2번~3번, 3번~4번을 '미리 구해서 저장.'
4. dirs 변수 리스트 준비: '짝수 홀수 판단 -> 이후 순차적 검색으로 해당 인덱스에 맞춰 방향 설정'.
    0:회전X, 1:시계회전, -1:반시계회전
5. conditons 변수 리스트를 통해 비교 프로세스 시작.
    5-1. 현재 타겟 바퀴의 오른쪽 톱니바퀴들 순차적으로 검토.
    5-2. // 왼쪽 톱니바퀴들 순차적으로 검토.
6. dirs를 통해, 배열 재조정.
(반복 k값 만큼)
7. 답 출력
"""

# 14891 : Gear

s=input
gears=[0]+[[*map(int,s())] for _ in [0]*4]

for _ in[0]*int(s()):
    num,dir=map(int,s().split())
    con=[0,gears[1][2]!=gears[2][6], gears[2][2]!=gears[3][6], gears[3][2]!=gears[4][6]] # none / (1,2) / (2,3) / (3,4)
    
    dirs=[0]*5
    dirs[num] = dir
    
    # Check right side gears
    for i in range(num, 4):
        if con[i]:
            dirs[i+1] = -dirs[i]
        else:
            break
    
    # Check left side gears
    for i in range(num-1, 0, -1):
        if con[i]:
            dirs[i] = -dirs[i+1]
        else:
            break
    
    # Apply rotations
    for i in range(1, 5):
        if dirs[i] == 1:
            gears[i] = [gears[i][-1]] + gears[i][:-1]
        elif dirs[i] == -1:
            gears[i] = gears[i][1:] + [gears[i][0]]

print(sum(2**(i-1) for i in range(1,5) if gears[i][0]))
