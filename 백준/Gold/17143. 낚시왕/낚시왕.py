"""
난이도: 쉬움~보통(해결법1), 어려움(해결법2)
시간: 20분, 1시간 20분

<핵심 프로세스 파악>
메인로직은 문제에서 잘 설명해주었다.
1. 특정 행 도착
2. 상어 잡기
3. 상어 이동
여기서, 알고리즘의 시간복잡도가 갈리는 부분은 3번 상어 이동 과정이다.
이를 바탕으로, 설계는 상어이동 과정을 기준으로 2가지로 나뉜다.

* 해결법1
"상어 이동을 반복문을 통해 구현하자."
=> while을 통해, 수동으로 상어의 위치를 옮기는 작업.
=> 속력의 크기가 커지면 커질수록, 그만큼 반복연산이 일어난다.
=> 즉, 해당 과정에서만 O(n*n)을 뛰어넘을 수 있다는 의미.

* 해결법2
"상어 이동을 위치를 기준으로 수학적으로 접근하자."
=> 수학적 규칙을 찾으면, O(1)로 고정되므로, 문제에서 요구되는 시간을 지킬 수 있다.
=> 그러므로, 해결법2를 최종 선택하여, 설계 start

<요구사항 파악>
1. 상어의 정보를 어떻게 저장할 것인가?
    => 우선, 초기 낚시장 정보는 이중 리스트로 담는 것은 확정이다.
    => 이후, 메인로직 2번과 3번 연산시, 어떻게 안정성을 보장할 것인지에 대한 고민이 필요.
        핵심 주의점: '상어의 크기에 따라, 한 공간에 상어가 여러마리 있다면, 1명만 살아남는다.'
    => 즉, 약육강식의 법칙.(기준: 몸무게)
    => 이에 따른 처리 과정은 다음과 같은 두가지 과정으로 나뉜다.
        -(1) 상어를 기존 배열에서 이동시키면서, 약육강식을 적용한다.
        -(2) 순차적으로 상어를 이동시키면서, 이동이 완료된 상어들끼리 약육강식을 먼저 진행한다.
    => (1)의 경우, 잘못된 결과를 초래한다.
        예를 들어, 1번과 2번 상어가 존재한다고 가정하자.(크기:1번>2번)
        1번 상어가 이동한 후의 위치가 2번 상어가 존재하는 곳이라고 가정한다면, 2번 상어는 잡아먹힌다.
        그러나, 문제 요구사항은 '모든 상어는 동시에 움직인다.'
        즉, '2번 상어까지 이동한 후에 약육강식 법칙을 적용'해야 한다는 것이다.
    => 그러므로, (2)번을 선택하였으며, 이를 구현하기 위해 '새로운 낚시장을 개설.'
        새로운 낚시장 == 새로운 이중 리스트
        이곳에 순차적으로 '최종 이동 위치에 상어 정보를 넣는다.'
        만약, 현재 작업 대상의 상어의 최종 이동 위치가 같다면,
        '서로 이동을 마친 상어들'이므로, 약육강식 적용을 해도 무관.
        모든 상어 이동 작업을 마쳤다면, 이 새로운 낚시장을 덮어쓰기!
    => 그렇다면, 이중 리스트에 상어 정보는?
        이동과 관련된 핵심은, 속력/방향/크기이므로, 튜플(속력,방향,크기)를 저장하면 된다.
        (어처피, 상어가 없는 위치는 0으로 표시하기 때문.)
        또 다른 방식도 가능하긴 함.
            - Queue에 상어정보를 저장하여, Queue를 순차적으로 탐색하면서 이동작업.
            그러나, Queue에 넣는 작업에서 시간낭비 발생. 비효율적.

2. 상어의 이동은 수학적으로 어떻게 나타내는가?
    => 규칙을 찾아내기 가장 어려운 부분이었다. 그렇기에 이 문제가 난이도가 높은 것으로 다가왔다.
    => 핵심은 "상어의 이동위치는 팰린드롬 수로써 사이클을 이룬다."이다.
    => 예를 들어보자.
        LEFT,RIGHT 방향만 생각.(가장 익숙한 방향 + 나머지 방향도 원리는 같음)
        C=6이고, 한개의 상어 이동을 생각해보자.(속력,방향,크기)=(8,right,아무거나)
        다음은 배열을 시각화한것이며, ()부분이 상어의 초기 위치이다.
        (0) 1 2 3 4 5 -- 정답 --> 0 1 (2) 3 4 5
        이동 과정을 자세히 살펴보자.
        (0) 1 2 3 4 5
              2 3 4
        되돌아온다는 사실을 알 수 있으며, 이는 팰린드롬 수와 같다.
        즉, 상어는 배열의 C크기에 맞춰, 다음의 범위 내에서만 위치가 고정된다.
        0 1 2 3 4 5 4 3 2 1 0 ==> 사이클!
        그러므로, 이 사이클을 기준으로 삼아, 'N사이클을 돈 후, 마지막 사이클의 0~C사이에서 몇번 움직이냐'이다.
        구체적으로 살펴보자.
        0 1 (2) 3 4 5 ==> 초기 배열. C=6, 상어의 위치는 2번쨰 열. 속력=8
        0 1 (2) 3 4 5 4 3 2 1 (0) ==> 맨 오른쪽 ()가 정답 위치. (사이클을 1차원으로 표현)
        여기서 상어의 속력에 따른 사이클을 가상으로 생성하고, '이 기준 사이클과 비교한다.'
        0 1 (2) 3 4 5 4 3 2 1 (0) ==> 기준 사이클 (상어 0위치 가정)
            (2) 3 4 5 4 3 2 1 [0] [1] ==> 현재 생성 사이클(속력==현재 사이클의 기본 길이)
        즉, 기준 사이클의 개수와 맞추기 위해 속력+='상어위치'를 진행한다.(속력=8+2=10 == 기존 사이클 길이)
        이 상태에서 '사이클은 반복되므로, 현재생성사이클%기준사이클를 통해 나온 나머지를 구한다.'
        이 나머지의 의미 : '0 1 2 3 4 5에서 0부터의 이동횟수' == '최종 이동 위치'
        즉 정리하자면 프로세스는 다음과 같다.
            기준 사이클 생성 길이(cycle) : C*2-2
            현재 생성 사이클 길이(speed_cycle) : 속력+상어의위치
            0~5 범위 내에서 최종 이동 횟수 : speed_cycle % cycle
            if 최종이동횟수 >= C:
                마지막 사이클의 범위가 C를 넘어간 것이므로
                then, cycle-speed_cycle이 최종이동횟수가 되고, 이값이 상어의 최종 이동 위치!
                이때, C를 넘어간 것은 '역행이란 의미.'
            else:
                마지막 사이클의 범위가 C를 넘어가지 않았으므로, 0에서부터 이동하는 횟수를 의미 
                then, speed_cycle이 최종이동횟수가되고, 이값이 상어 위치!
                이때, C를 넘어가지 않았으므로, '순행이란 의미'
        이때, 주의점은 역행하는 경우이다. 만약, LEFT이면?
        0 1 2 3 4 5에서 1->0->1->2->3->4->5... 순으로 사이클이 생성되므로,
        현재 생성 사이클 길이가 Right랑 반대로, 속력+(cycle-상어의위치)가 된다.
    => 그러므로, 정리하자면 다음과 같다.
        기준 사이클 생성 길이(cycle) : C*2-2
        현재 생성 사이클 길이(speed_cycle)
            - 역행(LEFT) : 속력+(cycle-상어위치)
            - 순행(RIGHT) : 속력+상어위치
        0~5 범위 내에서 최종 이동 횟수 : speed_cycle % cycle
        if speed_cycle >= C:
            최종 상어 위치(행,열,방향) = (상어 행 위치, cycle-speed_cycle, LEFT)
        else:
            최종 상어 위치 = (상어 행 위치, speed_cycle, RIGHT)

이를 토대로 메인 로직 구현!
"""

# 17143 : The Greatest of fishing

from sys import stdin 
scan=lambda:map(int,stdin.readline().split())

def catch(col):
    for row in range(R):
        if spots[row][col]:
            target=spots[row][col][2]
            spots[row][col]=0
            return target
    return 0

def next_shark_location(rowIdx,colIdx,speed_cycle,dir):
    # 길이의 기준이 행인 경우
    if dir==UP or dir==DOWN:
        cycle=R*2-2
        
        if dir==UP:speed_cycle+=cycle-rowIdx # 역행인 경우
        else:speed_cycle+=rowIdx # 순행인 경우
        
        speed_cycle%=cycle # 마지막 사이클의 나머지 파악(최종이동횟수)
        return (cycle-speed_cycle,colIdx,UP) if speed_cycle>=R else (speed_cycle,colIdx,DOWN)
    # 길이의 기준이 열인 경우
    else: # 위의 UP/DOWN과 원리 같음. 사용 변수만 다를 뿐!
        cycle=C*2-2
        
        if dir==LEFT:speed_cycle+=cycle-colIdx
        else:speed_cycle+=colIdx
        
        speed_cycle%=cycle
        return (rowIdx,cycle-speed_cycle,LEFT) if speed_cycle>=C else (rowIdx,speed_cycle,RIGHT)

def move_shark():
    new_spots=[[0]*C for _ in [0]*R] # 새로운 낚시장
    for i in range(R):
        for j in range(C):
            # 기존 낚시장 상어 발견시
            if spots[i][j]:
                # 해당 상어 최종 이동 위치 파악
                nx,ny,nd=next_shark_location(i,j,spots[i][j][0],spots[i][j][1]) # r,c,speed,direction
                # 새로운 낚시장에 이동을 마친 상어가 존재할 경우
                if new_spots[nx][ny]:
                    # 약육강식 적용
                    new_spots[nx][ny]=max(new_spots[nx][ny],(spots[i][j][0],nd,spots[i][j][2]),
                                          key=lambda x:x[2])
                else:
                    new_spots[nx][ny]=(spots[i][j][0],nd,spots[i][j][2])
    return new_spots # 기존 낚시장 -> 새로운 낚시장

R,C,m=scan()
spots=[[0]*C for _ in [0]*R]
UP,DOWN,RIGHT,LEFT=1,2,3,4
total=0 # 정답

for _ in [0]*m:
    r,c,s,d,z=scan()
    spots[r-1][c-1]=(s,d,z) # 원소타입: (speed,direction,weight)

# 메인로직 1 : 낚시꾼 열 이동.
for col in range(C):
    total+=catch(col) # 메인로직 2 : 상어 잡기
    spots=move_shark() # 메인로직 3 : 상어 이동
print(total)
